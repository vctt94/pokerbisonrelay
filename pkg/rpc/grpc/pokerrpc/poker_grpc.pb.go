// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: poker.proto

package pokerrpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PokerService_StartGameStream_FullMethodName = "/poker.PokerService/StartGameStream"
	PokerService_ShowCards_FullMethodName       = "/poker.PokerService/ShowCards"
	PokerService_HideCards_FullMethodName       = "/poker.PokerService/HideCards"
	PokerService_MakeBet_FullMethodName         = "/poker.PokerService/MakeBet"
	PokerService_CallBet_FullMethodName         = "/poker.PokerService/CallBet"
	PokerService_FoldBet_FullMethodName         = "/poker.PokerService/FoldBet"
	PokerService_CheckBet_FullMethodName        = "/poker.PokerService/CheckBet"
	PokerService_GetGameState_FullMethodName    = "/poker.PokerService/GetGameState"
	PokerService_EvaluateHand_FullMethodName    = "/poker.PokerService/EvaluateHand"
	PokerService_GetLastWinners_FullMethodName  = "/poker.PokerService/GetLastWinners"
)

// PokerServiceClient is the client API for PokerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PokerService handles the actual poker game mechanics
type PokerServiceClient interface {
	// Game stream for real-time updates
	StartGameStream(ctx context.Context, in *StartGameStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GameUpdate], error)
	// Card visibility management
	ShowCards(ctx context.Context, in *ShowCardsRequest, opts ...grpc.CallOption) (*ShowCardsResponse, error)
	HideCards(ctx context.Context, in *HideCardsRequest, opts ...grpc.CallOption) (*HideCardsResponse, error)
	// Player actions
	MakeBet(ctx context.Context, in *MakeBetRequest, opts ...grpc.CallOption) (*MakeBetResponse, error)
	CallBet(ctx context.Context, in *CallBetRequest, opts ...grpc.CallOption) (*CallBetResponse, error)
	FoldBet(ctx context.Context, in *FoldBetRequest, opts ...grpc.CallOption) (*FoldBetResponse, error)
	CheckBet(ctx context.Context, in *CheckBetRequest, opts ...grpc.CallOption) (*CheckBetResponse, error)
	// Game state
	GetGameState(ctx context.Context, in *GetGameStateRequest, opts ...grpc.CallOption) (*GetGameStateResponse, error)
	// Hand evaluation
	EvaluateHand(ctx context.Context, in *EvaluateHandRequest, opts ...grpc.CallOption) (*EvaluateHandResponse, error)
	// Returns the last completed showdown winners (cached), independent of current phase
	GetLastWinners(ctx context.Context, in *GetLastWinnersRequest, opts ...grpc.CallOption) (*GetLastWinnersResponse, error)
}

type pokerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPokerServiceClient(cc grpc.ClientConnInterface) PokerServiceClient {
	return &pokerServiceClient{cc}
}

func (c *pokerServiceClient) StartGameStream(ctx context.Context, in *StartGameStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GameUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PokerService_ServiceDesc.Streams[0], PokerService_StartGameStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartGameStreamRequest, GameUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PokerService_StartGameStreamClient = grpc.ServerStreamingClient[GameUpdate]

func (c *pokerServiceClient) ShowCards(ctx context.Context, in *ShowCardsRequest, opts ...grpc.CallOption) (*ShowCardsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShowCardsResponse)
	err := c.cc.Invoke(ctx, PokerService_ShowCards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) HideCards(ctx context.Context, in *HideCardsRequest, opts ...grpc.CallOption) (*HideCardsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HideCardsResponse)
	err := c.cc.Invoke(ctx, PokerService_HideCards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) MakeBet(ctx context.Context, in *MakeBetRequest, opts ...grpc.CallOption) (*MakeBetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MakeBetResponse)
	err := c.cc.Invoke(ctx, PokerService_MakeBet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) CallBet(ctx context.Context, in *CallBetRequest, opts ...grpc.CallOption) (*CallBetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallBetResponse)
	err := c.cc.Invoke(ctx, PokerService_CallBet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) FoldBet(ctx context.Context, in *FoldBetRequest, opts ...grpc.CallOption) (*FoldBetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FoldBetResponse)
	err := c.cc.Invoke(ctx, PokerService_FoldBet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) CheckBet(ctx context.Context, in *CheckBetRequest, opts ...grpc.CallOption) (*CheckBetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckBetResponse)
	err := c.cc.Invoke(ctx, PokerService_CheckBet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) GetGameState(ctx context.Context, in *GetGameStateRequest, opts ...grpc.CallOption) (*GetGameStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGameStateResponse)
	err := c.cc.Invoke(ctx, PokerService_GetGameState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) EvaluateHand(ctx context.Context, in *EvaluateHandRequest, opts ...grpc.CallOption) (*EvaluateHandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluateHandResponse)
	err := c.cc.Invoke(ctx, PokerService_EvaluateHand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pokerServiceClient) GetLastWinners(ctx context.Context, in *GetLastWinnersRequest, opts ...grpc.CallOption) (*GetLastWinnersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLastWinnersResponse)
	err := c.cc.Invoke(ctx, PokerService_GetLastWinners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PokerServiceServer is the server API for PokerService service.
// All implementations must embed UnimplementedPokerServiceServer
// for forward compatibility.
//
// PokerService handles the actual poker game mechanics
type PokerServiceServer interface {
	// Game stream for real-time updates
	StartGameStream(*StartGameStreamRequest, grpc.ServerStreamingServer[GameUpdate]) error
	// Card visibility management
	ShowCards(context.Context, *ShowCardsRequest) (*ShowCardsResponse, error)
	HideCards(context.Context, *HideCardsRequest) (*HideCardsResponse, error)
	// Player actions
	MakeBet(context.Context, *MakeBetRequest) (*MakeBetResponse, error)
	CallBet(context.Context, *CallBetRequest) (*CallBetResponse, error)
	FoldBet(context.Context, *FoldBetRequest) (*FoldBetResponse, error)
	CheckBet(context.Context, *CheckBetRequest) (*CheckBetResponse, error)
	// Game state
	GetGameState(context.Context, *GetGameStateRequest) (*GetGameStateResponse, error)
	// Hand evaluation
	EvaluateHand(context.Context, *EvaluateHandRequest) (*EvaluateHandResponse, error)
	// Returns the last completed showdown winners (cached), independent of current phase
	GetLastWinners(context.Context, *GetLastWinnersRequest) (*GetLastWinnersResponse, error)
	mustEmbedUnimplementedPokerServiceServer()
}

// UnimplementedPokerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPokerServiceServer struct{}

func (UnimplementedPokerServiceServer) StartGameStream(*StartGameStreamRequest, grpc.ServerStreamingServer[GameUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method StartGameStream not implemented")
}
func (UnimplementedPokerServiceServer) ShowCards(context.Context, *ShowCardsRequest) (*ShowCardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowCards not implemented")
}
func (UnimplementedPokerServiceServer) HideCards(context.Context, *HideCardsRequest) (*HideCardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HideCards not implemented")
}
func (UnimplementedPokerServiceServer) MakeBet(context.Context, *MakeBetRequest) (*MakeBetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeBet not implemented")
}
func (UnimplementedPokerServiceServer) CallBet(context.Context, *CallBetRequest) (*CallBetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallBet not implemented")
}
func (UnimplementedPokerServiceServer) FoldBet(context.Context, *FoldBetRequest) (*FoldBetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FoldBet not implemented")
}
func (UnimplementedPokerServiceServer) CheckBet(context.Context, *CheckBetRequest) (*CheckBetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBet not implemented")
}
func (UnimplementedPokerServiceServer) GetGameState(context.Context, *GetGameStateRequest) (*GetGameStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameState not implemented")
}
func (UnimplementedPokerServiceServer) EvaluateHand(context.Context, *EvaluateHandRequest) (*EvaluateHandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateHand not implemented")
}
func (UnimplementedPokerServiceServer) GetLastWinners(context.Context, *GetLastWinnersRequest) (*GetLastWinnersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastWinners not implemented")
}
func (UnimplementedPokerServiceServer) mustEmbedUnimplementedPokerServiceServer() {}
func (UnimplementedPokerServiceServer) testEmbeddedByValue()                      {}

// UnsafePokerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PokerServiceServer will
// result in compilation errors.
type UnsafePokerServiceServer interface {
	mustEmbedUnimplementedPokerServiceServer()
}

func RegisterPokerServiceServer(s grpc.ServiceRegistrar, srv PokerServiceServer) {
	// If the following call pancis, it indicates UnimplementedPokerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PokerService_ServiceDesc, srv)
}

func _PokerService_StartGameStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartGameStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PokerServiceServer).StartGameStream(m, &grpc.GenericServerStream[StartGameStreamRequest, GameUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PokerService_StartGameStreamServer = grpc.ServerStreamingServer[GameUpdate]

func _PokerService_ShowCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).ShowCards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_ShowCards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).ShowCards(ctx, req.(*ShowCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_HideCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HideCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).HideCards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_HideCards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).HideCards(ctx, req.(*HideCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_MakeBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakeBetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).MakeBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_MakeBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).MakeBet(ctx, req.(*MakeBetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_CallBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallBetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).CallBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_CallBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).CallBet(ctx, req.(*CallBetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_FoldBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FoldBetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).FoldBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_FoldBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).FoldBet(ctx, req.(*FoldBetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_CheckBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).CheckBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_CheckBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).CheckBet(ctx, req.(*CheckBetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_GetGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGameStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).GetGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_GetGameState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).GetGameState(ctx, req.(*GetGameStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_EvaluateHand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateHandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).EvaluateHand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_EvaluateHand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).EvaluateHand(ctx, req.(*EvaluateHandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PokerService_GetLastWinners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastWinnersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PokerServiceServer).GetLastWinners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PokerService_GetLastWinners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PokerServiceServer).GetLastWinners(ctx, req.(*GetLastWinnersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PokerService_ServiceDesc is the grpc.ServiceDesc for PokerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PokerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "poker.PokerService",
	HandlerType: (*PokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShowCards",
			Handler:    _PokerService_ShowCards_Handler,
		},
		{
			MethodName: "HideCards",
			Handler:    _PokerService_HideCards_Handler,
		},
		{
			MethodName: "MakeBet",
			Handler:    _PokerService_MakeBet_Handler,
		},
		{
			MethodName: "CallBet",
			Handler:    _PokerService_CallBet_Handler,
		},
		{
			MethodName: "FoldBet",
			Handler:    _PokerService_FoldBet_Handler,
		},
		{
			MethodName: "CheckBet",
			Handler:    _PokerService_CheckBet_Handler,
		},
		{
			MethodName: "GetGameState",
			Handler:    _PokerService_GetGameState_Handler,
		},
		{
			MethodName: "EvaluateHand",
			Handler:    _PokerService_EvaluateHand_Handler,
		},
		{
			MethodName: "GetLastWinners",
			Handler:    _PokerService_GetLastWinners_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartGameStream",
			Handler:       _PokerService_StartGameStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "poker.proto",
}

const (
	LobbyService_CreateTable_FullMethodName             = "/poker.LobbyService/CreateTable"
	LobbyService_JoinTable_FullMethodName               = "/poker.LobbyService/JoinTable"
	LobbyService_LeaveTable_FullMethodName              = "/poker.LobbyService/LeaveTable"
	LobbyService_GetTables_FullMethodName               = "/poker.LobbyService/GetTables"
	LobbyService_GetPlayerCurrentTable_FullMethodName   = "/poker.LobbyService/GetPlayerCurrentTable"
	LobbyService_GetBalance_FullMethodName              = "/poker.LobbyService/GetBalance"
	LobbyService_UpdateBalance_FullMethodName           = "/poker.LobbyService/UpdateBalance"
	LobbyService_ProcessTip_FullMethodName              = "/poker.LobbyService/ProcessTip"
	LobbyService_SetPlayerReady_FullMethodName          = "/poker.LobbyService/SetPlayerReady"
	LobbyService_SetPlayerUnready_FullMethodName        = "/poker.LobbyService/SetPlayerUnready"
	LobbyService_StartNotificationStream_FullMethodName = "/poker.LobbyService/StartNotificationStream"
)

// LobbyServiceClient is the client API for LobbyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LobbyService handles table management and player connections
type LobbyServiceClient interface {
	// Table management
	CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*CreateTableResponse, error)
	JoinTable(ctx context.Context, in *JoinTableRequest, opts ...grpc.CallOption) (*JoinTableResponse, error)
	LeaveTable(ctx context.Context, in *LeaveTableRequest, opts ...grpc.CallOption) (*LeaveTableResponse, error)
	GetTables(ctx context.Context, in *GetTablesRequest, opts ...grpc.CallOption) (*GetTablesResponse, error)
	GetPlayerCurrentTable(ctx context.Context, in *GetPlayerCurrentTableRequest, opts ...grpc.CallOption) (*GetPlayerCurrentTableResponse, error)
	// Player management
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	UpdateBalance(ctx context.Context, in *UpdateBalanceRequest, opts ...grpc.CallOption) (*UpdateBalanceResponse, error)
	ProcessTip(ctx context.Context, in *ProcessTipRequest, opts ...grpc.CallOption) (*ProcessTipResponse, error)
	// Ready state management
	SetPlayerReady(ctx context.Context, in *SetPlayerReadyRequest, opts ...grpc.CallOption) (*SetPlayerReadyResponse, error)
	SetPlayerUnready(ctx context.Context, in *SetPlayerUnreadyRequest, opts ...grpc.CallOption) (*SetPlayerUnreadyResponse, error)
	// Notification stream
	StartNotificationStream(ctx context.Context, in *StartNotificationStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Notification], error)
}

type lobbyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLobbyServiceClient(cc grpc.ClientConnInterface) LobbyServiceClient {
	return &lobbyServiceClient{cc}
}

func (c *lobbyServiceClient) CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*CreateTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTableResponse)
	err := c.cc.Invoke(ctx, LobbyService_CreateTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) JoinTable(ctx context.Context, in *JoinTableRequest, opts ...grpc.CallOption) (*JoinTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinTableResponse)
	err := c.cc.Invoke(ctx, LobbyService_JoinTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) LeaveTable(ctx context.Context, in *LeaveTableRequest, opts ...grpc.CallOption) (*LeaveTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveTableResponse)
	err := c.cc.Invoke(ctx, LobbyService_LeaveTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) GetTables(ctx context.Context, in *GetTablesRequest, opts ...grpc.CallOption) (*GetTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTablesResponse)
	err := c.cc.Invoke(ctx, LobbyService_GetTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) GetPlayerCurrentTable(ctx context.Context, in *GetPlayerCurrentTableRequest, opts ...grpc.CallOption) (*GetPlayerCurrentTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlayerCurrentTableResponse)
	err := c.cc.Invoke(ctx, LobbyService_GetPlayerCurrentTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, LobbyService_GetBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) UpdateBalance(ctx context.Context, in *UpdateBalanceRequest, opts ...grpc.CallOption) (*UpdateBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBalanceResponse)
	err := c.cc.Invoke(ctx, LobbyService_UpdateBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) ProcessTip(ctx context.Context, in *ProcessTipRequest, opts ...grpc.CallOption) (*ProcessTipResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessTipResponse)
	err := c.cc.Invoke(ctx, LobbyService_ProcessTip_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) SetPlayerReady(ctx context.Context, in *SetPlayerReadyRequest, opts ...grpc.CallOption) (*SetPlayerReadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPlayerReadyResponse)
	err := c.cc.Invoke(ctx, LobbyService_SetPlayerReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) SetPlayerUnready(ctx context.Context, in *SetPlayerUnreadyRequest, opts ...grpc.CallOption) (*SetPlayerUnreadyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPlayerUnreadyResponse)
	err := c.cc.Invoke(ctx, LobbyService_SetPlayerUnready_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyServiceClient) StartNotificationStream(ctx context.Context, in *StartNotificationStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Notification], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LobbyService_ServiceDesc.Streams[0], LobbyService_StartNotificationStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StartNotificationStreamRequest, Notification]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyService_StartNotificationStreamClient = grpc.ServerStreamingClient[Notification]

// LobbyServiceServer is the server API for LobbyService service.
// All implementations must embed UnimplementedLobbyServiceServer
// for forward compatibility.
//
// LobbyService handles table management and player connections
type LobbyServiceServer interface {
	// Table management
	CreateTable(context.Context, *CreateTableRequest) (*CreateTableResponse, error)
	JoinTable(context.Context, *JoinTableRequest) (*JoinTableResponse, error)
	LeaveTable(context.Context, *LeaveTableRequest) (*LeaveTableResponse, error)
	GetTables(context.Context, *GetTablesRequest) (*GetTablesResponse, error)
	GetPlayerCurrentTable(context.Context, *GetPlayerCurrentTableRequest) (*GetPlayerCurrentTableResponse, error)
	// Player management
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	UpdateBalance(context.Context, *UpdateBalanceRequest) (*UpdateBalanceResponse, error)
	ProcessTip(context.Context, *ProcessTipRequest) (*ProcessTipResponse, error)
	// Ready state management
	SetPlayerReady(context.Context, *SetPlayerReadyRequest) (*SetPlayerReadyResponse, error)
	SetPlayerUnready(context.Context, *SetPlayerUnreadyRequest) (*SetPlayerUnreadyResponse, error)
	// Notification stream
	StartNotificationStream(*StartNotificationStreamRequest, grpc.ServerStreamingServer[Notification]) error
	mustEmbedUnimplementedLobbyServiceServer()
}

// UnimplementedLobbyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLobbyServiceServer struct{}

func (UnimplementedLobbyServiceServer) CreateTable(context.Context, *CreateTableRequest) (*CreateTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTable not implemented")
}
func (UnimplementedLobbyServiceServer) JoinTable(context.Context, *JoinTableRequest) (*JoinTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinTable not implemented")
}
func (UnimplementedLobbyServiceServer) LeaveTable(context.Context, *LeaveTableRequest) (*LeaveTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveTable not implemented")
}
func (UnimplementedLobbyServiceServer) GetTables(context.Context, *GetTablesRequest) (*GetTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTables not implemented")
}
func (UnimplementedLobbyServiceServer) GetPlayerCurrentTable(context.Context, *GetPlayerCurrentTableRequest) (*GetPlayerCurrentTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayerCurrentTable not implemented")
}
func (UnimplementedLobbyServiceServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedLobbyServiceServer) UpdateBalance(context.Context, *UpdateBalanceRequest) (*UpdateBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBalance not implemented")
}
func (UnimplementedLobbyServiceServer) ProcessTip(context.Context, *ProcessTipRequest) (*ProcessTipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessTip not implemented")
}
func (UnimplementedLobbyServiceServer) SetPlayerReady(context.Context, *SetPlayerReadyRequest) (*SetPlayerReadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPlayerReady not implemented")
}
func (UnimplementedLobbyServiceServer) SetPlayerUnready(context.Context, *SetPlayerUnreadyRequest) (*SetPlayerUnreadyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPlayerUnready not implemented")
}
func (UnimplementedLobbyServiceServer) StartNotificationStream(*StartNotificationStreamRequest, grpc.ServerStreamingServer[Notification]) error {
	return status.Errorf(codes.Unimplemented, "method StartNotificationStream not implemented")
}
func (UnimplementedLobbyServiceServer) mustEmbedUnimplementedLobbyServiceServer() {}
func (UnimplementedLobbyServiceServer) testEmbeddedByValue()                      {}

// UnsafeLobbyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LobbyServiceServer will
// result in compilation errors.
type UnsafeLobbyServiceServer interface {
	mustEmbedUnimplementedLobbyServiceServer()
}

func RegisterLobbyServiceServer(s grpc.ServiceRegistrar, srv LobbyServiceServer) {
	// If the following call pancis, it indicates UnimplementedLobbyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LobbyService_ServiceDesc, srv)
}

func _LobbyService_CreateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).CreateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_CreateTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).CreateTable(ctx, req.(*CreateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_JoinTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).JoinTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_JoinTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).JoinTable(ctx, req.(*JoinTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_LeaveTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).LeaveTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_LeaveTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).LeaveTable(ctx, req.(*LeaveTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_GetTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).GetTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_GetTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).GetTables(ctx, req.(*GetTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_GetPlayerCurrentTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlayerCurrentTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).GetPlayerCurrentTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_GetPlayerCurrentTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).GetPlayerCurrentTable(ctx, req.(*GetPlayerCurrentTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_UpdateBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).UpdateBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_UpdateBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).UpdateBalance(ctx, req.(*UpdateBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_ProcessTip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessTipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).ProcessTip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_ProcessTip_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).ProcessTip(ctx, req.(*ProcessTipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_SetPlayerReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPlayerReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).SetPlayerReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_SetPlayerReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).SetPlayerReady(ctx, req.(*SetPlayerReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_SetPlayerUnready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPlayerUnreadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyServiceServer).SetPlayerUnready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyService_SetPlayerUnready_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyServiceServer).SetPlayerUnready(ctx, req.(*SetPlayerUnreadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyService_StartNotificationStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartNotificationStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LobbyServiceServer).StartNotificationStream(m, &grpc.GenericServerStream[StartNotificationStreamRequest, Notification]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyService_StartNotificationStreamServer = grpc.ServerStreamingServer[Notification]

// LobbyService_ServiceDesc is the grpc.ServiceDesc for LobbyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LobbyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "poker.LobbyService",
	HandlerType: (*LobbyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTable",
			Handler:    _LobbyService_CreateTable_Handler,
		},
		{
			MethodName: "JoinTable",
			Handler:    _LobbyService_JoinTable_Handler,
		},
		{
			MethodName: "LeaveTable",
			Handler:    _LobbyService_LeaveTable_Handler,
		},
		{
			MethodName: "GetTables",
			Handler:    _LobbyService_GetTables_Handler,
		},
		{
			MethodName: "GetPlayerCurrentTable",
			Handler:    _LobbyService_GetPlayerCurrentTable_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _LobbyService_GetBalance_Handler,
		},
		{
			MethodName: "UpdateBalance",
			Handler:    _LobbyService_UpdateBalance_Handler,
		},
		{
			MethodName: "ProcessTip",
			Handler:    _LobbyService_ProcessTip_Handler,
		},
		{
			MethodName: "SetPlayerReady",
			Handler:    _LobbyService_SetPlayerReady_Handler,
		},
		{
			MethodName: "SetPlayerUnready",
			Handler:    _LobbyService_SetPlayerUnready_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartNotificationStream",
			Handler:       _LobbyService_StartNotificationStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "poker.proto",
}
